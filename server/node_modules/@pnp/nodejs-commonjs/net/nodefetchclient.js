"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeFetchClient = void 0;
var tslib_1 = require("tslib");
var logging_1 = require("@pnp/logging-commonjs");
var fetch_js_1 = require("./fetch.js");
/**
 * Fetch client that encapsulates the node-fetch library and also adds retry logic
 * when encountering transient errors.
 */
var NodeFetchClient = /** @class */ (function () {
    /**
     *
     * @param retryCount: number - Maximum number of transient failure retries before throwing the error
     * @param retryInterval: number - Starting interval to delay the first retry attempt
     * @param minRetryInterval: number - Minimum retry delay boundary as retry intervals are randomly recalculated
     * @param maxRetryInterval: number - Maximum retry delay boundary as retry intervals are radnomaly recalculated
     */
    function NodeFetchClient(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        if (retryCount === void 0) { retryCount = 3; }
        if (retryInterval === void 0) { retryInterval = 3000; }
        if (minRetryInterval === void 0) { minRetryInterval = 3000; }
        if (maxRetryInterval === void 0) { maxRetryInterval = 90000; }
        this.retryCount = retryCount;
        this.retryInterval = retryInterval;
        this.minRetryInterval = minRetryInterval;
        this.maxRetryInterval = maxRetryInterval;
    }
    NodeFetchClient.prototype.fetch = function (url, options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var wrapper;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        wrapper = function (retryData) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                            var err_1, retry;
                            return (0, tslib_1.__generator)(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 7]);
                                        return [4 /*yield*/, (0, fetch_js_1.fetch)(url, options || {})];
                                    case 1: 
                                    // Try to make the request...
                                    return [2 /*return*/, _a.sent()];
                                    case 2:
                                        err_1 = _a.sent();
                                        retry = this.updateRetryData(retryData, err_1);
                                        // If there is no error code, this wasn't a transient error
                                        // so we throw immediately.
                                        if (!err_1.code) {
                                            throw err_1;
                                        }
                                        if (!(["ETIMEDOUT", "ESOCKETTIMEDOUT", "ECONNREFUSED", "ECONNRESET"].indexOf(err_1.code.toUpperCase()) > -1)) return [3 /*break*/, 6];
                                        logging_1.Logger.write("Attempt #" + retry.retryCount + " - Retrying error code: " + err_1.code + "...", 0 /* Verbose */);
                                        if (!this.shouldRetry(retry)) return [3 /*break*/, 5];
                                        return [4 /*yield*/, this.delay(retry.retryInterval)];
                                    case 3:
                                        _a.sent();
                                        return [4 /*yield*/, wrapper(retry)];
                                    case 4: return [2 /*return*/, _a.sent()];
                                    case 5: // max amount of retries reached, so throw the error
                                    throw err_1;
                                    case 6: return [3 /*break*/, 7];
                                    case 7: return [2 /*return*/];
                                }
                            });
                        }); };
                        return [4 /*yield*/, wrapper(null)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    NodeFetchClient.prototype.delay = function (ms) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        setTimeout(function () {
                            resolve();
                        }, ms);
                    })];
            });
        });
    };
    NodeFetchClient.prototype.updateRetryData = function (retryData, err) {
        var data = retryData || {
            error: null,
            retryCount: 0,
            retryInterval: 0,
        };
        var newError = err || null;
        // Keep track of errors from previous retries
        // if they exist
        if (newError) {
            if (data.error) {
                newError.innerError = data.error;
            }
            data.error = newError;
        }
        // Adjust retry interval and cap based on the min and max intervals specified
        var incrementDelta = Math.pow(2, data.retryCount) - 1;
        var boundedRandDelta = this.retryInterval * 0.8 +
            Math.floor(Math.random() * (this.retryInterval * 1.2 - this.retryInterval * 0.8));
        incrementDelta *= boundedRandDelta;
        // Adjust retry count
        data.retryCount++;
        data.retryInterval = Math.min(this.minRetryInterval + incrementDelta, this.maxRetryInterval);
        return data;
    };
    NodeFetchClient.prototype.shouldRetry = function (retryData) {
        if (!retryData) {
            throw new Error("ERROR: retryData cannot be null.");
        }
        var currentCount = (retryData && retryData.retryCount);
        return currentCount < this.retryCount;
    };
    return NodeFetchClient;
}());
exports.NodeFetchClient = NodeFetchClient;
//# sourceMappingURL=nodefetchclient.js.map
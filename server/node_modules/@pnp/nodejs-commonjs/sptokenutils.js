"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserAccessToken = exports.getAddInOnlyAccessToken = exports.validateProviderHostedRequestToken = void 0;
var tslib_1 = require("tslib");
var url_1 = require("url");
var jwt = require("jsonwebtoken");
var types_js_1 = require("./types.js");
var fetch_js_1 = require("./net/fetch.js");
var MapCacheManager = /** @class */ (function () {
    function MapCacheManager() {
        this.map = new Map();
    }
    MapCacheManager.prototype.getAccessToken = function (realm, cacheKey) {
        return this.map.get(this.buildKey(realm, cacheKey));
    };
    MapCacheManager.prototype.setAccessToken = function (realm, cacheKey, token) {
        this.map.set(this.buildKey(realm, cacheKey), token);
    };
    MapCacheManager.prototype.buildKey = function (realm, cacheKey) {
        return realm + ":" + cacheKey;
    };
    return MapCacheManager;
}());
var tokenCache = new MapCacheManager();
function validateProviderHostedRequestToken(requestToken, clientSecret) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        return (0, tslib_1.__generator)(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    var secret = Buffer.from(clientSecret, "base64");
                    jwt.verify(requestToken, secret, function (err, decoded) {
                        if (err) {
                            return reject(err);
                        }
                        resolve(decoded);
                    });
                })];
        });
    });
}
exports.validateProviderHostedRequestToken = validateProviderHostedRequestToken;
/**
 * Gets an add-in only authentication token based on the supplied site url, client id and secret
 */
function getAddInOnlyAccessToken(siteUrl, clientId, clientSecret, realm, stsUri) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        return (0, tslib_1.__generator)(this, function (_a) {
            return [2 /*return*/, getTokenInternal({ siteUrl: siteUrl, clientId: clientId, clientSecret: clientSecret, refreshToken: null, realm: realm, stsUri: stsUri, cacheKey: "addinonly:" + clientId })];
        });
    });
}
exports.getAddInOnlyAccessToken = getAddInOnlyAccessToken;
/**
 * Gets a user authentication token based on the supplied site url, client id, client secret, and refresh token
 */
// eslint-disable-next-line max-len
function getUserAccessToken(siteUrl, clientId, clientSecret, refreshToken, realm, stsUri, cacheKey) {
    return getTokenInternal({ siteUrl: siteUrl, clientId: clientId, clientSecret: clientSecret, refreshToken: refreshToken, realm: realm, stsUri: stsUri, cacheKey: "user:" + cacheKey });
}
exports.getUserAccessToken = getUserAccessToken;
function getTokenInternal(params) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var accessToken, resource, formattedClientId, body, r;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    accessToken = tokenCache.getAccessToken(params.realm, params.cacheKey);
                    if (accessToken && new Date() < toDate(accessToken.expires_on)) {
                        return [2 /*return*/, accessToken];
                    }
                    resource = getFormattedPrincipal(types_js_1.SharePointServicePrincipal, (0, url_1.parse)(params.siteUrl).hostname, params.realm);
                    formattedClientId = getFormattedPrincipal(params.clientId, "", params.realm);
                    body = [];
                    if (params.refreshToken) {
                        body.push("grant_type=refresh_token");
                        body.push("refresh_token=" + encodeURIComponent(params.refreshToken));
                    }
                    else {
                        body.push("grant_type=client_credentials");
                    }
                    body.push("client_id=" + formattedClientId);
                    body.push("client_secret=" + encodeURIComponent(params.clientSecret));
                    body.push("resource=" + resource);
                    return [4 /*yield*/, (0, fetch_js_1.fetch)(params.stsUri, {
                            body: body.join("&"),
                            headers: {
                                "Content-Type": "application/x-www-form-urlencoded",
                            },
                            method: "POST",
                        })];
                case 1:
                    r = _a.sent();
                    return [4 /*yield*/, r.json()];
                case 2:
                    accessToken = _a.sent();
                    tokenCache.setAccessToken(params.realm, params.cacheKey, accessToken);
                    return [2 /*return*/, accessToken];
            }
        });
    });
}
function getFormattedPrincipal(principalName, hostName, realm) {
    var resource = principalName;
    if (hostName !== null && hostName !== "") {
        resource += "/" + hostName;
    }
    resource += "@" + realm;
    return resource;
}
function toDate(epoch) {
    var tmp = parseInt(epoch, 10);
    if (tmp < 10000000000) {
        tmp *= 1000;
    }
    var d = new Date();
    d.setTime(tmp);
    return d;
}
//# sourceMappingURL=sptokenutils.js.map
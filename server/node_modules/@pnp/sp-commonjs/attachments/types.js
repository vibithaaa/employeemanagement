"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Attachment = exports._Attachment = exports.Attachments = exports._Attachments = void 0;
var tslib_1 = require("tslib");
var decorators_js_1 = require("../decorators.js");
var operations_js_1 = require("../operations.js");
var sharepointqueryable_js_1 = require("../sharepointqueryable.js");
var odata_1 = require("@pnp/odata-commonjs");
var telemetry_js_1 = require("../telemetry.js");
var _Attachments = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_Attachments, _super);
    function _Attachments() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
    * Gets a Attachment File by filename
    *
    * @param name The name of the file, including extension.
    */
    _Attachments.prototype.getByName = function (name) {
        var f = telemetry_js_1.tag.configure((0, exports.Attachment)(this), "ats.getByName");
        f.concat("('" + name + "')");
        return f;
    };
    /**
     * Adds a new attachment to the collection. Not supported for batching.
     *
     * @param name The name of the file, including extension.
     * @param content The Base64 file content.
     */
    _Attachments.prototype.add = function (name, content) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.Attachments, "add(FileName='" + name + "')", false), { body: content })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, {
                                data: response,
                                file: this.getByName(name),
                            }];
                }
            });
        });
    };
    /**
     * Adds multiple new attachment to the collection. Not supported for batching.
     *
     * @param files The collection of files to add
     */
    _Attachments.prototype.addMultiple = function (files) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var i;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < files.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.add(files[i].name, files[i].content)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete multiple attachments from the collection. Not supported for batching.
     *
     * @param files The collection of files to delete
     */
    _Attachments.prototype.deleteMultiple = function () {
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var i;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < files.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getByName(files[i]).delete()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete multiple attachments from the collection and send to recycle bin. Not supported for batching.
     *
     * @param files The collection of files to be deleted and sent to recycle bin
     */
    _Attachments.prototype.recycleMultiple = function () {
        var files = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            files[_i] = arguments[_i];
        }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var i;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < files.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getByName(files[i]).recycle()];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("ats.add")
    ], _Attachments.prototype, "add", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("ats.addMultiple")
    ], _Attachments.prototype, "addMultiple", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("ats.deleteMultiple")
    ], _Attachments.prototype, "deleteMultiple", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("ats.recycleMultiple")
    ], _Attachments.prototype, "recycleMultiple", null);
    _Attachments = (0, tslib_1.__decorate)([
        (0, decorators_js_1.defaultPath)("AttachmentFiles")
    ], _Attachments);
    return _Attachments;
}(sharepointqueryable_js_1._SharePointQueryableCollection));
exports._Attachments = _Attachments;
exports.Attachments = (0, sharepointqueryable_js_1.spInvokableFactory)(_Attachments);
var _Attachment = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_Attachment, _super);
    function _Attachment() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delete = (0, sharepointqueryable_js_1.deleteableWithETag)("at");
        return _this;
    }
    /**
     * Gets the contents of the file as text
     *
     */
    _Attachment.prototype.getText = function () {
        return this.getParsed(new odata_1.TextParser());
    };
    /**
     * Gets the contents of the file as a blob, does not work in Node.js
     *
     */
    _Attachment.prototype.getBlob = function () {
        return this.getParsed(new odata_1.BlobParser());
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js
     */
    _Attachment.prototype.getBuffer = function () {
        return this.getParsed(new odata_1.BufferParser());
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js
     */
    _Attachment.prototype.getJSON = function () {
        return this.getParsed(new odata_1.JSONParser());
    };
    /**
     * Sets the content of a file. Not supported for batching
     *
     * @param content The value to set for the file contents
     */
    _Attachment.prototype.setContent = function (content) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.Attachment, "$value", false), (0, odata_1.headers)({ "X-HTTP-Method": "PUT" }, {
                            body: content,
                        }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, (0, exports.Attachment)(this)];
                }
            });
        });
    };
    /**
     * Delete this attachment file and send it to recycle bin
     *
     * @param eTag Value used in the IF-Match header, by default "*"
     */
    _Attachment.prototype.recycle = function (eTag) {
        if (eTag === void 0) { eTag = "*"; }
        return (0, operations_js_1.spPost)(this.clone(exports.Attachment, "recycleObject"), (0, odata_1.headers)({
            "IF-Match": eTag,
            "X-HTTP-Method": "DELETE",
        }));
    };
    _Attachment.prototype.getParsed = function (parser) {
        return this.clone(exports.Attachment, "$value", false).usingParser(parser)();
    };
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.getText")
    ], _Attachment.prototype, "getText", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.getBlob")
    ], _Attachment.prototype, "getBlob", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.getBuffer")
    ], _Attachment.prototype, "getBuffer", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.getJSON")
    ], _Attachment.prototype, "getJSON", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.setContent")
    ], _Attachment.prototype, "setContent", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("at.recycle")
    ], _Attachment.prototype, "recycle", null);
    return _Attachment;
}(sharepointqueryable_js_1._SharePointQueryableInstance));
exports._Attachment = _Attachment;
exports.Attachment = (0, sharepointqueryable_js_1.spInvokableFactory)(_Attachment);
//# sourceMappingURL=types.js.map
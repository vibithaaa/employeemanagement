"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateFileType = exports.MoveOperations = exports.CheckinType = exports.Version = exports._Version = exports.Versions = exports._Versions = exports.File = exports._File = exports.Files = exports._Files = void 0;
var tslib_1 = require("tslib");
var sharepointqueryable_js_1 = require("../sharepointqueryable.js");
var odata_1 = require("@pnp/odata-commonjs");
var common_1 = require("@pnp/common-commonjs");
var index_js_1 = require("../items/index.js");
var odata_js_1 = require("../odata.js");
var decorators_js_1 = require("../decorators.js");
var operations_js_1 = require("../operations.js");
var escapeQueryStrValue_js_1 = require("../utils/escapeQueryStrValue.js");
var extractweburl_js_1 = require("../utils/extractweburl.js");
var telemetry_js_1 = require("../telemetry.js");
var toResourcePath_js_1 = require("../utils/toResourcePath.js");
/**
 * Describes a collection of File objects
 *
 */
var _Files = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_Files, _super);
    function _Files() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a File by filename
     *
     * @param name The name of the file, including extension.
     */
    _Files.prototype.getByName = function (name) {
        if (/%#/.test(name)) {
            throw Error("For file names containing % or # please use web.getFileByServerRelativePath");
        }
        return telemetry_js_1.tag.configure((0, exports.File)(this).concat("('" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(name) + "')"), "fis.getByName");
    };
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The file contents
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @returns The new File and the raw response.
     */
    _Files.prototype.add = function (url, content, shouldOverWrite) {
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)((0, exports.Files)(this, "add(overwrite=" + shouldOverWrite + ",url='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(url) + "')"), {
                            body: content,
                        })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, {
                                data: response,
                                file: this.getByName(url),
                            }];
                }
            });
        });
    };
    /**
     * Adds a file using the pound percent safe methods
     *
     * @param url Excoded url of the file
     * @param content The file content
     * @param parameters Additional parameters to control method behavior
     */
    _Files.prototype.addUsingPath = function (url, content, parameters) {
        if (parameters === void 0) { parameters = { Overwrite: false }; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var path, resp;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = ["AddUsingPath(decodedurl='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(url) + "'"];
                        if (parameters) {
                            if (parameters.Overwrite) {
                                path.push(",Overwrite=true");
                            }
                            if (parameters.AutoCheckoutOnInvalidData) {
                                path.push(",AutoCheckoutOnInvalidData=true");
                            }
                            if (!(0, common_1.stringIsNullOrEmpty)(parameters.XorHash)) {
                                path.push(",XorHash=" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(parameters.XorHash));
                            }
                        }
                        path.push(")");
                        return [4 /*yield*/, (0, operations_js_1.spPost)((0, exports.Files)(this, path.join("")), { body: content })];
                    case 1:
                        resp = _a.sent();
                        return [2 /*return*/, {
                                data: resp,
                                file: (0, exports.File)((0, odata_js_1.odataUrlFrom)(resp)),
                            }];
                }
            });
        });
    };
    /**
     * Uploads a file. Not supported for batching
     *
     * @param url The folder-relative url of the file.
     * @param content The Blob file content to add
     * @param progress A callback function which can be used to track the progress of the upload
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten? (default: true)
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     * @returns The new File and the raw response.
     */
    _Files.prototype.addChunked = function (url, content, progress, shouldOverWrite, chunkSize) {
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        if (chunkSize === void 0) { chunkSize = 10485760; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response, odataUrl, file;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.Files, "add(overwrite=" + shouldOverWrite + ",url='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(url) + "')", false))];
                    case 1:
                        response = _a.sent();
                        odataUrl = (0, odata_js_1.odataUrlFrom)(response);
                        if (!(0, common_1.stringIsNullOrEmpty)(odataUrl) && /%27/i.test(odataUrl)) {
                            odataUrl = odataUrl.replace(/%27/ig, "''");
                        }
                        file = (0, exports.File)(odataUrl);
                        return [4 /*yield*/, file.setContentChunked(content, progress, chunkSize)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Adds a ghosted file to an existing list or document library. Not supported for batching.
     *
     * @param fileUrl The server-relative url where you want to save the file.
     * @param templateFileType The type of use to create the file.
     * @returns The template file that was added and the raw response.
     */
    _Files.prototype.addTemplateFile = function (fileUrl, templateFileType) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.Files, "addTemplateFile(urloffile='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(fileUrl) + "',templatefiletype=" + templateFileType + ")", false))];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, {
                                data: response,
                                file: (0, exports.File)((0, odata_js_1.odataUrlFrom)(response)),
                            }];
                }
            });
        });
    };
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fis.add")
    ], _Files.prototype, "add", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fis.addUsingPath")
    ], _Files.prototype, "addUsingPath", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fis.addChunked")
    ], _Files.prototype, "addChunked", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fis.addTemplateFile")
    ], _Files.prototype, "addTemplateFile", null);
    _Files = (0, tslib_1.__decorate)([
        (0, decorators_js_1.defaultPath)("files")
    ], _Files);
    return _Files;
}(sharepointqueryable_js_1._SharePointQueryableCollection));
exports._Files = _Files;
exports.Files = (0, sharepointqueryable_js_1.spInvokableFactory)(_Files);
/**
 * Describes a single File instance
 *
 */
var _File = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_File, _super);
    function _File() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delete = (0, sharepointqueryable_js_1.deleteableWithETag)("fi");
        return _this;
    }
    Object.defineProperty(_File.prototype, "listItemAllFields", {
        /**
         * Gets a value that specifies the list item field values for the list item corresponding to the file.
         *
         */
        get: function () {
            return telemetry_js_1.tag.configure((0, sharepointqueryable_js_1.SharePointQueryableInstance)(this, "listItemAllFields"), "fi.listItemAllFields");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(_File.prototype, "versions", {
        /**
         * Gets a collection of versions
         *
         */
        get: function () {
            return telemetry_js_1.tag.configure((0, exports.Versions)(this), "fi.versions");
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Approves the file submitted for content approval with the specified comment.
     * Only documents in lists that are enabled for content approval can be approved.
     *
     * @param comment The comment for the approval.
     */
    _File.prototype.approve = function (comment) {
        if (comment === void 0) { comment = ""; }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "approve(comment='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(comment) + "')"));
    };
    /**
     * Stops the chunk upload session without saving the uploaded data. Does not support batching.
     * If the file doesn’t already exist in the library, the partially uploaded file will be deleted.
     * Use this in response to user action (as in a request to cancel an upload) or an error or exception.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     */
    _File.prototype.cancelUpload = function (uploadId) {
        return (0, operations_js_1.spPost)(this.clone(exports.File, "cancelUpload(uploadId=guid'" + uploadId + "')", false));
    };
    /**
     * Checks the file in to a document library based on the check-in type.
     *
     * @param comment A comment for the check-in. Its length must be <= 1023.
     * @param checkinType The check-in type for the file.
     */
    _File.prototype.checkin = function (comment, checkinType) {
        if (comment === void 0) { comment = ""; }
        if (checkinType === void 0) { checkinType = CheckinType.Major; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "checkin(comment='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(comment) + "',checkintype=" + checkinType + ")"));
    };
    /**
     * Checks out the file from a document library.
     */
    _File.prototype.checkout = function () {
        return (0, operations_js_1.spPost)(this.clone(exports.File, "checkout"));
    };
    /**
     * Copies the file to the destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to copy to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     */
    _File.prototype.copyTo = function (url, shouldOverWrite) {
        if (shouldOverWrite === void 0) { shouldOverWrite = true; }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "copyTo(strnewurl='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(url) + "',boverwrite=" + shouldOverWrite + ")"));
    };
    /**
     * Copies the file by path to destination path.
     * Also works with different site collections.
     *
     * @param destUrl The absolute url or server relative url of the destination file path to copy to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     * @param keepBoth Keep both if file with the same name in the same location already exists? Only relevant when shouldOverWrite is set to false.
     */
    _File.prototype.copyByPath = function (destUrl, shouldOverWrite, KeepBoth) {
        if (KeepBoth === void 0) { KeepBoth = false; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, srcUrl, absoluteUrl, webBaseUrl, hostUrl;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.select("ServerRelativeUrl")()];
                    case 1:
                        _a = _b.sent(), srcUrl = _a.ServerRelativeUrl, absoluteUrl = _a["odata.id"];
                        webBaseUrl = (0, extractweburl_js_1.extractWebUrl)(absoluteUrl);
                        hostUrl = webBaseUrl.replace("://", "___").split("/")[0].replace("___", "://");
                        return [4 /*yield*/, (0, operations_js_1.spPost)((0, exports.File)(webBaseUrl, "/_api/SP.MoveCopyUtil.CopyFileByPath(overwrite=@a1)?@a1=" + shouldOverWrite), (0, odata_1.body)({
                                destPath: (0, toResourcePath_js_1.toResourcePath)((0, common_1.isUrlAbsolute)(destUrl) ? destUrl : "" + hostUrl + destUrl),
                                options: {
                                    KeepBoth: KeepBoth,
                                    ResetAuthorAndCreatedOnCopy: true,
                                    ShouldBypassSharedLocks: true,
                                    __metadata: {
                                        type: "SP.MoveCopyOptions",
                                    },
                                },
                                srcPath: (0, toResourcePath_js_1.toResourcePath)((0, common_1.isUrlAbsolute)(srcUrl) ? srcUrl : "" + hostUrl + srcUrl),
                            }))];
                    case 2:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Denies approval for a file that was submitted for content approval.
     * Only documents in lists that are enabled for content approval can be denied.
     *
     * @param comment The comment for the denial.
     */
    _File.prototype.deny = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "deny(comment='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(comment) + "')"));
    };
    /**
     * Moves the file to the specified destination url.
     *
     * @param url The absolute url or server relative url of the destination file path to move to.
     * @param moveOperations The bitwise MoveOperations value for how to move the file.
     */
    _File.prototype.moveTo = function (url, moveOperations) {
        if (moveOperations === void 0) { moveOperations = MoveOperations.Overwrite; }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "moveTo(newurl='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(url) + "',flags=" + moveOperations + ")"));
    };
    /**
     * Moves the file by path to the specified destination url.
     * Also works with different site collections.
     *
     * @param destUrl The absolute url or server relative url of the destination file path to move to.
     * @param shouldOverWrite Should a file with the same name in the same location be overwritten?
     * @param keepBoth Keep both if file with the same name in the same location already exists? Only relevant when shouldOverWrite is set to false.
     */
    _File.prototype.moveByPath = function (destUrl, shouldOverWrite, KeepBoth) {
        if (KeepBoth === void 0) { KeepBoth = false; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, srcUrl, absoluteUrl, webBaseUrl, hostUrl;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.select("ServerRelativeUrl")()];
                    case 1:
                        _a = _b.sent(), srcUrl = _a.ServerRelativeUrl, absoluteUrl = _a["odata.id"];
                        webBaseUrl = (0, extractweburl_js_1.extractWebUrl)(absoluteUrl);
                        hostUrl = webBaseUrl.replace("://", "___").split("/")[0].replace("___", "://");
                        return [4 /*yield*/, (0, operations_js_1.spPost)((0, exports.File)(webBaseUrl, "/_api/SP.MoveCopyUtil.MoveFileByPath(overwrite=@a1)?@a1=" + shouldOverWrite), (0, odata_1.body)({
                                destPath: (0, toResourcePath_js_1.toResourcePath)((0, common_1.isUrlAbsolute)(destUrl) ? destUrl : "" + hostUrl + destUrl),
                                options: {
                                    KeepBoth: KeepBoth,
                                    ResetAuthorAndCreatedOnCopy: false,
                                    ShouldBypassSharedLocks: true,
                                    __metadata: {
                                        type: "SP.MoveCopyOptions",
                                    },
                                },
                                srcPath: (0, toResourcePath_js_1.toResourcePath)((0, common_1.isUrlAbsolute)(srcUrl) ? srcUrl : "" + hostUrl + srcUrl),
                            }))];
                    case 2:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Submits the file for content approval with the specified comment.
     *
     * @param comment The comment for the published file. Its length must be <= 1023.
     */
    _File.prototype.publish = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "publish(comment='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(comment) + "')"));
    };
    /**
     * Moves the file to the Recycle Bin and returns the identifier of the new Recycle Bin item.
     *
     * @returns The GUID of the recycled file.
     */
    _File.prototype.recycle = function () {
        return (0, operations_js_1.spPost)(this.clone(exports.File, "recycle"));
    };
    /**
     * Deletes the file object with options.
     *
     * @param parameters Specifies the options to use when deleting a file.
     */
    _File.prototype.deleteWithParams = function (parameters) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, (0, operations_js_1.spPost)(this.clone(exports.File, "DeleteWithParameters"), (0, odata_1.body)({ parameters: parameters }))];
            });
        });
    };
    /**
     * Reverts an existing checkout for the file.
     *
     */
    _File.prototype.undoCheckout = function () {
        return (0, operations_js_1.spPost)(this.clone(exports.File, "undoCheckout"));
    };
    /**
     * Removes the file from content approval or unpublish a major version.
     *
     * @param comment The comment for the unpublish operation. Its length must be <= 1023.
     */
    _File.prototype.unpublish = function (comment) {
        if (comment === void 0) { comment = ""; }
        if (comment.length > 1023) {
            throw Error("The maximum comment length is 1023 characters.");
        }
        return (0, operations_js_1.spPost)(this.clone(exports.File, "unpublish(comment='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(comment) + "')"));
    };
    /**
     * Checks to see if the file represented by this object exists
     *
     */
    _File.prototype.exists = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var r, e_1;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.clone(exports.File).select("Exists")()];
                    case 1:
                        r = _a.sent();
                        return [2 /*return*/, r.Exists];
                    case 2:
                        e_1 = _a.sent();
                        // this treats any error here as the file not existing, which
                        // might not be true, but is good enough.
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Gets the contents of the file as text. Not supported in batching.
     *
     */
    _File.prototype.getText = function () {
        return this.clone(exports.File, "$value", false).usingParser(new odata_1.TextParser())((0, odata_1.headers)({ "binaryStringResponseBody": "true" }));
    };
    /**
     * Gets the contents of the file as a blob, does not work in Node.js. Not supported in batching.
     *
     */
    _File.prototype.getBlob = function () {
        return this.clone(exports.File, "$value", false).usingParser(new odata_1.BlobParser())((0, odata_1.headers)({ "binaryStringResponseBody": "true" }));
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    _File.prototype.getBuffer = function () {
        return this.clone(exports.File, "$value", false).usingParser(new odata_1.BufferParser())((0, odata_1.headers)({ "binaryStringResponseBody": "true" }));
    };
    /**
     * Gets the contents of a file as an ArrayBuffer, works in Node.js. Not supported in batching.
     */
    _File.prototype.getJSON = function () {
        return this.clone(exports.File, "$value", false).usingParser(new odata_1.JSONParser())((0, odata_1.headers)({ "binaryStringResponseBody": "true" }));
    };
    /**
     * Sets the content of a file, for large files use setContentChunked. Not supported in batching.
     *
     * @param content The file content
     *
     */
    _File.prototype.setContent = function (content) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.File, "$value", false), {
                            body: content,
                            headers: {
                                "X-HTTP-Method": "PUT",
                            },
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, (0, exports.File)(this)];
                }
            });
        });
    };
    /**
     * Gets the associated list item for this file, loading the default properties
     */
    _File.prototype.getItem = function () {
        var selects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selects[_i] = arguments[_i];
        }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var q, d;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        q = this.listItemAllFields;
                        return [4 /*yield*/, q.select.apply(q, (0, tslib_1.__spreadArray)([], (0, tslib_1.__read)(selects), false))()];
                    case 1:
                        d = _a.sent();
                        return [2 /*return*/, (0, common_1.assign)((0, index_js_1.Item)((0, odata_js_1.odataUrlFrom)(d)), d)];
                }
            });
        });
    };
    /**
     * Sets the contents of a file using a chunked upload approach. Not supported in batching.
     *
     * @param file The file to upload
     * @param progress A callback function which can be used to track the progress of the upload
     * @param chunkSize The size of each file slice, in bytes (default: 10485760)
     */
    _File.prototype.setContentChunked = function (file, progress, chunkSize) {
        if (chunkSize === void 0) { chunkSize = 10485760; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var fileSize, totalBlocks, uploadId, currentPointer, i;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(0, common_1.isFunc)(progress)) {
                            progress = function () { return null; };
                        }
                        fileSize = file.size;
                        totalBlocks = parseInt((fileSize / chunkSize).toString(), 10) + ((fileSize % chunkSize === 0) ? 1 : 0);
                        uploadId = (0, common_1.getGUID)();
                        // report that we are starting
                        progress({ uploadId: uploadId, blockNumber: 1, chunkSize: chunkSize, currentPointer: 0, fileSize: fileSize, stage: "starting", totalBlocks: totalBlocks });
                        return [4 /*yield*/, this.startUpload(uploadId, file.slice(0, chunkSize))];
                    case 1:
                        currentPointer = _a.sent();
                        i = 2;
                        _a.label = 2;
                    case 2:
                        if (!(i < totalBlocks)) return [3 /*break*/, 5];
                        progress({ uploadId: uploadId, blockNumber: i, chunkSize: chunkSize, currentPointer: currentPointer, fileSize: fileSize, stage: "continue", totalBlocks: totalBlocks });
                        return [4 /*yield*/, this.continueUpload(uploadId, currentPointer, file.slice(currentPointer, currentPointer + chunkSize))];
                    case 3:
                        currentPointer = _a.sent();
                        _a.label = 4;
                    case 4:
                        i++;
                        return [3 /*break*/, 2];
                    case 5:
                        progress({ uploadId: uploadId, blockNumber: totalBlocks, chunkSize: chunkSize, currentPointer: currentPointer, fileSize: fileSize, stage: "finishing", totalBlocks: totalBlocks });
                        return [2 /*return*/, this.finishUpload(uploadId, currentPointer, file.slice(currentPointer))];
                }
            });
        });
    };
    /**
     * Starts a new chunk upload session and uploads the first fragment.
     * The current file content is not changed when this method completes.
     * The method is idempotent (and therefore does not change the result) as long as you use the same values for uploadId and stream.
     * The upload session ends either when you use the CancelUpload method or when you successfully
     * complete the upload session by passing the rest of the file contents through the ContinueUpload and FinishUpload methods.
     * The StartUpload and ContinueUpload methods return the size of the running total of uploaded data in bytes,
     * so you can pass those return values to subsequent uses of ContinueUpload and FinishUpload.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    _File.prototype.startUpload = function (uploadId, fragment) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var n;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.File, "startUpload(uploadId=guid'" + uploadId + "')", false), { body: fragment })];
                    case 1:
                        n = _a.sent();
                        if (typeof n === "object") {
                            // When OData=verbose the payload has the following shape:
                            // { StartUpload: "10485760" }
                            n = n.StartUpload;
                        }
                        return [2 /*return*/, parseFloat(n)];
                }
            });
        });
    };
    /**
     * Continues the chunk upload session with an additional fragment.
     * The current file content is not changed.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The size of the total uploaded data in bytes.
     */
    _File.prototype.continueUpload = function (uploadId, fileOffset, fragment) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var n;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.File, "continueUpload(uploadId=guid'" + uploadId + "',fileOffset=" + fileOffset + ")", false), { body: fragment })];
                    case 1:
                        n = _a.sent();
                        if (typeof n === "object") {
                            // When OData=verbose the payload has the following shape:
                            // { ContinueUpload: "20971520" }
                            n = n.ContinueUpload;
                        }
                        return [2 /*return*/, parseFloat(n)];
                }
            });
        });
    };
    /**
     * Uploads the last file fragment and commits the file. The current file content is changed when this method completes.
     * Use the uploadId value that was passed to the StartUpload method that started the upload session.
     * This method is currently available only on Office 365.
     *
     * @param uploadId The unique identifier of the upload session.
     * @param fileOffset The size of the offset into the file where the fragment starts.
     * @param fragment The file contents.
     * @returns The newly uploaded file.
     */
    _File.prototype.finishUpload = function (uploadId, fileOffset, fragment) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var response;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, operations_js_1.spPost)(this.clone(exports.File, "finishUpload(uploadId=guid'" + uploadId + "',fileOffset=" + fileOffset + ")", false), { body: fragment })];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, {
                                data: response,
                                file: (0, exports.File)((0, odata_js_1.odataUrlFrom)(response)),
                            }];
                }
            });
        });
    };
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.approve")
    ], _File.prototype, "approve", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.cancelUpload")
    ], _File.prototype, "cancelUpload", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.checkin")
    ], _File.prototype, "checkin", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.checkout")
    ], _File.prototype, "checkout", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.copyTo")
    ], _File.prototype, "copyTo", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.copyByPath")
    ], _File.prototype, "copyByPath", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.deny")
    ], _File.prototype, "deny", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.moveTo")
    ], _File.prototype, "moveTo", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.moveByPath")
    ], _File.prototype, "moveByPath", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.publish")
    ], _File.prototype, "publish", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.recycle")
    ], _File.prototype, "recycle", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.del-params")
    ], _File.prototype, "deleteWithParams", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.undoCheckout")
    ], _File.prototype, "undoCheckout", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.unpublish")
    ], _File.prototype, "unpublish", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.exists")
    ], _File.prototype, "exists", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.getText")
    ], _File.prototype, "getText", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.getBlob")
    ], _File.prototype, "getBlob", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.getBuffer")
    ], _File.prototype, "getBuffer", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.getJSON")
    ], _File.prototype, "getJSON", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.setContent")
    ], _File.prototype, "setContent", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.getItem")
    ], _File.prototype, "getItem", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.startUpload")
    ], _File.prototype, "startUpload", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.continueUpload")
    ], _File.prototype, "continueUpload", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("fi.finishUpload")
    ], _File.prototype, "finishUpload", null);
    return _File;
}(sharepointqueryable_js_1._SharePointQueryableInstance));
exports._File = _File;
exports.File = (0, sharepointqueryable_js_1.spInvokableFactory)(_File);
/**
 * Describes a collection of Version objects
 *
 */
var _Versions = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_Versions, _super);
    function _Versions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a version by id
     *
     * @param versionId The id of the version to retrieve
     */
    _Versions.prototype.getById = function (versionId) {
        return telemetry_js_1.tag.configure((0, exports.Version)(this).concat("(" + versionId + ")"), "vers.getById");
    };
    /**
     * Deletes all the file version objects in the collection.
     *
     */
    _Versions.prototype.deleteAll = function () {
        return (0, operations_js_1.spPost)((0, exports.Versions)(this, "deleteAll"));
    };
    /**
     * Deletes the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    _Versions.prototype.deleteById = function (versionId) {
        return (0, operations_js_1.spPost)(this.clone(exports.Versions, "deleteById(vid=" + versionId + ")"));
    };
    /**
     * Recycles the specified version of the file.
     *
     * @param versionId The ID of the file version to delete.
     */
    _Versions.prototype.recycleByID = function (versionId) {
        return (0, operations_js_1.spPost)(this.clone(exports.Versions, "recycleByID(vid=" + versionId + ")"));
    };
    /**
     * Deletes the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    _Versions.prototype.deleteByLabel = function (label) {
        return (0, operations_js_1.spPost)(this.clone(exports.Versions, "deleteByLabel(versionlabel='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(label) + "')"));
    };
    /**
     * Recycles the file version object with the specified version label.
     *
     * @param label The version label of the file version to delete, for example: 1.2
     */
    _Versions.prototype.recycleByLabel = function (label) {
        return (0, operations_js_1.spPost)(this.clone(exports.Versions, "recycleByLabel(versionlabel='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(label) + "')"));
    };
    /**
     * Creates a new file version from the file specified by the version label.
     *
     * @param label The version label of the file version to restore, for example: 1.2
     */
    _Versions.prototype.restoreByLabel = function (label) {
        return (0, operations_js_1.spPost)(this.clone(exports.Versions, "restoreByLabel(versionlabel='" + (0, escapeQueryStrValue_js_1.escapeQueryStrValue)(label) + "')"));
    };
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.deleteAll")
    ], _Versions.prototype, "deleteAll", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.deleteById")
    ], _Versions.prototype, "deleteById", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.recycleByID")
    ], _Versions.prototype, "recycleByID", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.deleteByLabel")
    ], _Versions.prototype, "deleteByLabel", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.recycleByLabel")
    ], _Versions.prototype, "recycleByLabel", null);
    (0, tslib_1.__decorate)([
        (0, telemetry_js_1.tag)("vers.restoreByLabel")
    ], _Versions.prototype, "restoreByLabel", null);
    _Versions = (0, tslib_1.__decorate)([
        (0, decorators_js_1.defaultPath)("versions")
    ], _Versions);
    return _Versions;
}(sharepointqueryable_js_1._SharePointQueryableCollection));
exports._Versions = _Versions;
exports.Versions = (0, sharepointqueryable_js_1.spInvokableFactory)(_Versions);
/**
 * Describes a single Version instance
 *
 */
var _Version = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(_Version, _super);
    function _Version() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.delete = (0, sharepointqueryable_js_1.deleteableWithETag)("ver");
        return _this;
    }
    return _Version;
}(sharepointqueryable_js_1._SharePointQueryableInstance));
exports._Version = _Version;
exports.Version = (0, sharepointqueryable_js_1.spInvokableFactory)(_Version);
/**
 * Types for document check in.
 * Minor = 0
 * Major = 1
 * Overwrite = 2
 */
var CheckinType;
(function (CheckinType) {
    CheckinType[CheckinType["Minor"] = 0] = "Minor";
    CheckinType[CheckinType["Major"] = 1] = "Major";
    CheckinType[CheckinType["Overwrite"] = 2] = "Overwrite";
})(CheckinType = exports.CheckinType || (exports.CheckinType = {}));
/**
 * File move opertions
 */
var MoveOperations;
(function (MoveOperations) {
    /**
     * Produce an error if a file with the same name exists in the destination
     */
    MoveOperations[MoveOperations["None"] = 0] = "None";
    /**
     * Overwrite a file with the same name if it exists. Value is 1.
     */
    MoveOperations[MoveOperations["Overwrite"] = 1] = "Overwrite";
    /**
     * Complete the move operation even if supporting files are separated from the file. Value is 8.
     */
    MoveOperations[MoveOperations["AllowBrokenThickets"] = 8] = "AllowBrokenThickets";
    /**
     * Boolean specifying whether to retain the source of the move's editor and modified by datetime.
     */
    MoveOperations[MoveOperations["RetainEditorAndModifiedOnMove"] = 2048] = "RetainEditorAndModifiedOnMove";
})(MoveOperations = exports.MoveOperations || (exports.MoveOperations = {}));
var TemplateFileType;
(function (TemplateFileType) {
    TemplateFileType[TemplateFileType["StandardPage"] = 0] = "StandardPage";
    TemplateFileType[TemplateFileType["WikiPage"] = 1] = "WikiPage";
    TemplateFileType[TemplateFileType["FormPage"] = 2] = "FormPage";
    TemplateFileType[TemplateFileType["ClientSidePage"] = 3] = "ClientSidePage";
})(TemplateFileType = exports.TemplateFileType || (exports.TemplateFileType = {}));
//# sourceMappingURL=types.js.map
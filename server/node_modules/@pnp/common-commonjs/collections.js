"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeMaps = exports.objectToMap = void 0;
var util_js_1 = require("./util.js");
/**
 * Used to calculate the object properties, with polyfill if needed
 */
var objectEntries = (0, util_js_1.isFunc)(Object.entries) ? Object.entries : function (o) { return Object.keys(o).map(function (k) { return [k, o[k]]; }); };
/**
 * Converts the supplied object to a map
 *
 * @param o The object to map
 */
function objectToMap(o) {
    if ((0, util_js_1.objectDefinedNotNull)(o)) {
        return new Map(objectEntries(o));
    }
    return new Map();
}
exports.objectToMap = objectToMap;
/**
 * Merges to Map instances together, overwriting values in target with matching keys, last in wins
 *
 * @param target map into which the other maps are merged
 * @param maps One or more maps to merge into the target
 */
function mergeMaps(target) {
    var maps = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        maps[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < maps.length; i++) {
        maps[i].forEach(function (v, k) {
            // let's not run the spfx context through Object.assign :)
            if ((typeof k === "string" && k !== "spfxContext") && Object.prototype.toString.call(v) === "[object Object]") {
                // we only handle one level of deep object merging
                target.set(k, Object.assign({}, target.get(k) || {}, v));
            }
            else {
                target.set(k, v);
            }
        });
    }
    return target;
}
exports.mergeMaps = mergeMaps;
//# sourceMappingURL=collections.js.map